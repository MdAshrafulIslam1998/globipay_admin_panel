// AutoGenerated file for ChatScreenController
// generate date: 16/10/24 08:01 PM
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/services.dart';
import 'package:globipay_admin_panel/core/constants/enum/chat_session_type.dart';
import 'package:globipay_admin_panel/core/data/model/pagination_request.dart';
import 'package:globipay_admin_panel/core/services/navigator/app_navigator_service.dart';
import 'package:globipay_admin_panel/core/utils/custom_dialog.dart';
import 'package:globipay_admin_panel/core/utils/inputFilter/input_filter.dart';
import 'package:globipay_admin_panel/core/widgets/text_filed/input_field.dart';
import 'package:globipay_admin_panel/core/widgets/text_filed/input_regex.dart';
import 'package:globipay_admin_panel/data/models/call_model.dart';
import 'package:globipay_admin_panel/data/repository/app_repository.dart';
import 'package:globipay_admin_panel/entity/request/agora/agora_token_request_entity.dart';
import 'package:globipay_admin_panel/entity/request/call/send_call_request_entity.dart';
import 'package:globipay_admin_panel/entity/request/chat_close/chat_close_request_entity.dart';
import 'package:globipay_admin_panel/entity/response/agora/agora_token_response_entity.dart';
import 'package:globipay_admin_panel/entity/response/chat_close/chat_close_response_entity.dart';
import 'package:globipay_admin_panel/entity/response/messages_templates/message_templates_item_entity.dart';
import 'package:globipay_admin_panel/entity/response/messages_templates/messages_templates_response_entity.dart';
import 'package:globipay_admin_panel/modules/chat/chat_screen/views/message_templates_view.dart';
import 'package:globipay_admin_panel/modules/chat/chat_screen/views/widgets/chat_close_dialog.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:globipay_admin_panel/core/base/base_controller.dart';
import 'package:globipay_admin_panel/core/constants/enum/user_type.dart';
import 'package:globipay_admin_panel/core/data/local/repository/token_repository.dart';
import 'package:globipay_admin_panel/core/di/injector.dart';
import 'package:globipay_admin_panel/core/widgets/app_print.dart';
import 'package:globipay_admin_panel/data/services/supabase_service.dart';
import 'package:globipay_admin_panel/entity/response/message/message.dart';
import 'package:globipay_admin_panel/modules/chat/controller/chat_shared_controller.dart';
import 'package:globipay_admin_panel/router/app_routes.dart';
import 'package:globipay_admin_panel/router/route_path.dart';
import 'package:storage_client/storage_client.dart';
import 'dart:typed_data';

/**
 * Created by Abdullah on 16/10/24 08:01 PM.
 */
class ChatController extends BaseController {
  // Variables
  RxList<Message> messages = RxList<Message>([]);
  RxBool isTyping = false.obs;
  final supabase = SupabaseService().client;
  final ChatSharedController sharedController =
      Injector.resolve<ChatSharedController>();
  ScrollController scrollController = ScrollController();

  final TextEditingController messageController = TextEditingController();
  TextEditingController primaryCoinController = TextEditingController();
  TextEditingController secondaryCoinController = TextEditingController();


  // Constructor
  final TokenRepository tokenRepository;
  final AppRepository appRepository;

  ChatController(this.tokenRepository,this.appRepository);

  GlobalKey<FormState> chatCloseFormKey = GlobalKey<FormState>();
  Timer? _typingTimer;
  bool _isTyping = false;
  var templates =  <MessageTemplatesItemEntity>[].obs; // Your list of templates
  var showTemplates = false.obs; // Controls the split view

  final ValueNotifier<List<MessageTemplatesItemEntity>> filteredTemplates = ValueNotifier<List<MessageTemplatesItemEntity>>([]);
  final ValueNotifier<String> selectedCategory = ValueNotifier<String>('All');
  String searchQuery = '';

  late RealtimeChannel incomingMessageChannelSubscription ;

  @override
  void onInit() async{
    incomingMessageChannelSubscription = await supabase.channel('public:messages');
    fetchTemplates();
    _initializeMessages();
    _onListener();
    super.onInit();
  }
  // Get unique categories from templates
  List<String> getUniqueCategories() {
    return templates
        .map((template) => template.category_name ?? "")
        .where((category) => category.isNotEmpty) // Filter out empty strings
        .toSet()
        .toList()
      ..sort();
  }

  bool isChatSessionClosed() {
    return sharedController.chatSessionResponse?.status == ChatSessionType.CLOSED.code;
  }


  // Handle category selection
  void onCategorySelected(String category) {
    selectedCategory.value = category;
    _applyFilters();
  }

  // Handle search text changes
  void onSearchChanged(String query) {
    searchQuery = query;
    _applyFilters();
  }

  // Apply both category and search filters
  void _applyFilters() {
    List<MessageTemplatesItemEntity> result = List.from(templates);

    // Apply category filter
    if (selectedCategory.value != 'All') {
      result = result.where((template) =>
      template.category_name == selectedCategory.value).toList();
    }

    // Apply search filter
    if (searchQuery.isNotEmpty) {
      result = result.where((template) =>
      (template.title??"").toLowerCase().contains(searchQuery.toLowerCase()) ||
          (template.description ?? "").toLowerCase().contains(searchQuery.toLowerCase()) ||
          (template.category_name ??"").toLowerCase().contains(searchQuery.toLowerCase())
      ).toList();
    }

    filteredTemplates.value = result;
  }


  void fetchTemplates() {
    requestForMessageTemplates();
  }
  
  void onTemplateSelected(String template) {
    messageController.text = template;
    messageController.selection = TextSelection.fromPosition(
        TextPosition(offset: messageController.text.length));
  }

  void _onListener(){
    messageController.addListener(_onTyping);
  }

  void _initializeMessages() async{
    await markAllMessageAsSeen();
    getUserInfo();
    listenForMessages();
    fetchMessagesForSession(sharedController.chatSessionId ?? "");
  }

  //
  Future<void> getUserInfo() async {
    final userId = await tokenRepository.getUserID();
    final response = await supabase
        .from('users')
        .select()
        .eq('user_id', userId)
        .single(); // Use .single() to get a single row result

    if (response != null) {
      appPrint('User::::::::::::::::::: $response');
      // Now you can use userInfo as needed
    } else {
      appPrint('Error fetching user info: ${response.error?.message}');
    }
  }

  // Method to send a text message
  Future<void> sendTextMessage(String text, {String? textType}) async {
    final response = await supabase.from('messages').insert({
      'session_id': sharedController.chatSessionId,
      'sender_id': sharedController.currentUserId,
      'message': text,
      'message_type': textType ?? 'text', // Specify message type
      'status': 'sent', // Initial status
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Admin.name,
      'delivery_status': {
        'sent': DateTime.now().toIso8601String(),
      } // Corrected structure
    }).select('id').execute(); // Add .select('id') to fetch the inserted id

    if (response == null) {
      print('Error inserting message: ${response}');
      return;
    }

    // Access the inserted id
    String? messageID;
    if (response.data != null && response.data.isNotEmpty) {
      messageID = response.data[0]['id'] as String?;
    }

    if (messageID != null) {
     await markMessageAsDelivered(messageID);
      appPrint('Inserted message ID::::::::::::::::::::> $messageID');
    } else {
      appPrint('Message ID not found in the response.');
    }

    updateLastMessage(
        sessionId: sharedController.chatSessionId ?? "",
        message: text,
        isSeen: false,
        messageType: 'text'
    );
  }

  //TODO Delivered Message Update UI

  Future<void> sendMediaMessage(String url, {String? textType}) async {
    final response = await supabase.from('messages').insert({
      'session_id': sharedController.chatSessionId,
      'sender_id': sharedController.currentUserId,
      'message_type': textType ?? 'text',
      'status': 'sent', // Initial status
      'media_url': url,
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Customer.name
    }).execute();


    updateLastMessage(
      sessionId: sharedController.chatSessionId ?? "",
      message: "new image message",
      isSeen: false,
      messageType: 'image'
    );
  }

  // Real-time listener for new messages
  void listenForMessages() async{
    appPrint('Setting up listener for messages...');

    // Create a channel for the 'messages' table with the public schema, filtered by session_id
    //final channel = supabase.channel('public:messages')
    incomingMessageChannelSubscription..on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          // Here we apply the filter for session_id
          filter: 'session_id=eq.${sharedController.chatSessionId}',
        ),
        (payload, [ref]) async {
          if (payload['new'] != null) {
            final newMessage = Message.fromJson(payload['new']);

            Future.delayed(const Duration(seconds: 1)).then((value) async{
              if(newMessage.sender_id != sharedController.currentUserId){
                await markSingleMessageAsSeen(newMessage.id ?? "");
              }

              appPrint('New message INSERT: ${newMessage.toJson()}');
              // Add the new message to the list
              messages.add(newMessage);

              // Update the UI
              update();

              // Scroll to the bottom of the chat
              scrollToBottom();
            });

          } else {
            appPrint('No new message found in payload: $payload');
          }
        },
      )..on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'UPDATE',
          schema: 'public',
          table: 'messages',
          filter: 'session_id=eq.${sharedController.chatSessionId}',
        ),
            (payload, [ref]) {
              appPrint("UPDATE  Payload ::::> $payload");

              if (payload['new'] != null)  {
                 Future.delayed(const Duration(seconds: 1)).then((value) {
                   final updatedMessage = Message.fromJson(payload['new']);
                   final index = messages.indexWhere((msg) => msg.id == updatedMessage.id);
                   if (index != -1) {
                     messages[index] = updatedMessage;
                     update();
                   }
                 });
          }
        },
      ).subscribe();
  }

  // Mark message as delivered
  Future<void> markMessageAsDelivered(String messageId) async {
    try {
      await supabase.from('messages').update({
        'delivery_status': {
          'delivered': DateTime.now().toIso8601String(),
        }
      }).eq('id', messageId)
          .execute();
    } catch (e) {
      appPrint('Error marking message as delivered: $e');
    }
  }

  // Mark message as seen
  Future<void> markAllMessageAsSeen()async {
    appPrint('--------------------------------------------------------------------');
    appPrint('Marking all messages as seen');
    appPrint('Session ID: ${sharedController.chatSessionId}');
    appPrint('Current ID: ${sharedController.currentUserId}');
    appPrint('Partner ID: ${sharedController.chatPartnerId}');
    appPrint('--------------------------------------------------------------------');
    try {
      await supabase.from('messages').update({
        'delivery_status': {
          'seen': DateTime.now().toIso8601String()
        }
      }).eq('session_id', sharedController.chatSessionId)
          .neq('sender_id', sharedController.currentUserId)
          .execute();
      appPrint('All Messages marked as seen');
    } catch (e) {
      appPrint('Error marking message as seen: $e');
    }
  }

  Future<void> markSingleMessageAsSeen(String messageId)async {
    try {
      await supabase.from('messages').update({
        'delivery_status': {
          'seen': DateTime.now().toIso8601String()
        }
      }).eq('id', messageId)
          .execute();
      appPrint('Single Message marked as seen: $messageId');
    } catch (e) {
      appPrint('Error marking message as seen: $e');
    }
  }




  Future<void> updateTypingStatus(bool isTyping) async {

    final sessionId = sharedController.chatSessionId;
    if (sessionId == null) {
      return;
    }

    appPrint('Updating typing status: $isTyping');

    final loggedInUserId = await tokenRepository.getUserID();


    final isSender = loggedInUserId == sharedController.customer_id;
    final field = isSender ? 'is_sender_typing' : 'is_receiver_typing';
    await supabase
        .from('chat_sessions')
        .update({field: isTyping}).eq('session_id', sessionId);
  }

  Future<void> updateLastMessage({
    required String sessionId,
    required String message,
    required bool isSeen,
    required String messageType,
  }) async {
    await supabase.from('chat_sessions').update({
      'last_message': message,
      'last_message_timestamp': DateTime.now().toIso8601String(),
      'is_last_message_seen': isSeen,
      'message_type' : messageType
    }).eq('session_id', sessionId);

    appPrint('Updated last message for session $sessionId');

  }



  //Load all messages

  void fetchMessagesForSession(String sessionId) async {
    try {
      // Fetch messages for the specified session ID
      final response = await supabase
          .from('messages')
          .select('*') // Select all columns or specify the ones you need
          .eq('session_id', sessionId)
          .order('created_at', ascending: true)
          .execute();

      if (response.data == null) {
        throw Exception('Failed to fetch messages: ${response.data}');
      }

      // Parse the response to your message entity
      final messagesList = (response.data as List)
          .map((item) => Message.fromJson(item))
          .toList();

      // Set the fetched messages to your message list or state variable
      messages.value = messagesList;

      appPrint(
          'Fetched ${messagesList.length} messages for session $sessionId');
    } catch (e) {
      print('Exception while loading messages: $e');
    }
  }

  void scrollToBottom() {
    Future.delayed(const Duration(milliseconds: 100), () {
      scrollController.jumpTo(scrollController.position.maxScrollExtent);
    });
  }

  void _onTyping() {
    if (!_isTyping) {
      _isTyping = true;
      updateTypingStatus(true); // User started typing
    }

    // Cancel the previous timer and start a new one
    _typingTimer?.cancel();
    _typingTimer = Timer(const Duration(seconds: 2), () {
      _isTyping = false;
      updateTypingStatus(false); // User stopped typing
    });
  }

  void onAudioCall() {
    SnackBar snackBar = SnackBar(
      content: Text("Upcoming feature"),
      backgroundColor: Colors.green,
    );
    ScaffoldMessenger.of(AppNavigatorService.navigatorKey.currentState!.context).showSnackBar(snackBar);
  }

  Future<void> onVideoCall() async {
    requestForAgoraToken();
  }


  void onChatClose(BuildContext context) {


    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {


        return AlertDialog(
          title: Text("Close Chat"),
          content: Form(
            key: chatCloseFormKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Primary Coin Input Field
                InputField(
                  controller: primaryCoinController,
                  regex: InputRegex.NOT_EMPTY,
                  inputFormatters: InputFilter.AMOUNT_INPUT_FILTER,
                  hintText: "Primary Coin",

                ),
                SizedBox(height: 10),
                // Secondary Coin Input Field
                InputField(
                  controller: secondaryCoinController,
                  regex: InputRegex.NOT_EMPTY,
                  maxLength: 10,
                  inputFormatters: InputFilter.AMOUNT_INPUT_FILTER,
                  hintText: "Secondary Coin",

                ),
              ],
            ),
          ),
          actions: [
            // Cancel Button
            TextButton(
              onPressed: () {
                AppRoutes.pop();
              },
              child: Text("Cancel"),
            ),
            // Submit Button
            ElevatedButton(
              onPressed: () {
                if (chatCloseFormKey.currentState!.validate()) {
                  AppRoutes.pop();
                  requestToCloseChatSession();
                }
              },
              child: Text("Submit"),
            ),
          ],
        );
      },
    );
  }

  ChatCloseRequestEntity chatCloseRequestEntity(String createdById){
    return ChatCloseRequestEntity(
      primaryCoin: primaryCoinController.text.isNotEmpty ? double.tryParse(primaryCoinController.text) : 0.0,
      secondaryCoin: secondaryCoinController.text.isNotEmpty ? double.tryParse(secondaryCoinController.text) : 0.0,
      catId: int.tryParse(sharedController.chatSessionResponse?.category ?? "-1"),
      uid: sharedController.chatSessionResponse?.customer_id ?? "",
      createdBy: createdById,
    );
  }

  requestToCloseChatSession() async{
    final cId = await getLoggedInUserId();
    final req = chatCloseRequestEntity(cId);
    final repo = appRepository.requestToCloseChat(req);
    callService(repo,onSuccess: (ChatCloseResponseEntity response){
      parseChatCloseSession(response);
    });
  }

  parseChatCloseSession(ChatCloseResponseEntity response){
    updateSupabaseChatSession();
  }

  updateSupabaseChatSession() async{

    // Update the chat session status to closed
    try {
      await supabase.from('chat_sessions').update({
        'status': 'closed',
        'closed_at': DateTime.now().toIso8601String(),
      }).eq('session_id', sharedController.chatSessionId).execute();
    } catch (e) {
      print('Error closing chat session: $e');
    }
    showCustomDialog(
      "Chat session closed successfully : ${sharedController.chatSessionId}",
      positiveButtonText: "Ok",
      positiveButtonAction: (){
        AppRoutes.pop();
      }
    );

  }

  void onSendMessageFromPhotoLibrary() async {
    selectAndUploadFile();
  }


  void selectAndUploadImage() async {
    final Uint8List? imageBytes = await pickImageFromGallery();

    if (imageBytes != null) {
      final String? imageUrl = await uploadImage(imageBytes);
      if (imageUrl != null) {
        await sendMediaMessage(imageUrl, textType: 'image');
      } else {
        appPrint("Failed to upload the image.");
      }
    } else {
      appPrint("No image selected");
    }
  }

// Function to pick an image from the gallery
  Future<Uint8List?> pickImageFromGallery() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
      );

      if (result != null) {
        return result.files.single.bytes; // Return the image bytes
      }
    } catch (e) {
      appPrint("Error picking image: $e");
    }

    return null;
  }

  Future<String?> uploadImage(Uint8List imageFile) async {
    try {
      // Define a unique file name for the image
      final String fileName =
          'images/${DateTime.now().millisecondsSinceEpoch}.png';

      // Upload the file to Supabase storage
      final  response = await supabase.storage.from('chats').uploadBinary(
        fileName,
        imageFile,
        fileOptions: FileOptions(contentType: 'image/png'), // Set MIME type for PNG
      );

      // Check if the upload was successful
      if (response != null) {
        // Get the public URL of the uploaded image
        final String publicUrl = supabase.storage.from('chats').getPublicUrl(fileName);
        return publicUrl; // Return the URL of the uploaded image
      } else {
        appPrint('Image upload failed: ${response}');
        return null;
      }
    } catch (e) {
      print('Error uploading image: $e');
      return null;
    }
  }



  // Camera Related stuffs
  void requestCameraPermission() async {
    // Check the current permission status
    /*var cameraStatus = await Permission.camera.status;

    if (cameraStatus.isGranted) {
      // Permission already granted, open the camera
      final imageFile =
          await captureImage(); // Add your camera image capture logic here
      if (imageFile != null) {
        final imageUrl = await uploadImage(imageFile);
        await sendMediaMessage(imageUrl ?? "",
            textType: 'image'); // Send the message with the image URL
      }
      appPrint("Camera permission granted");
    } else if (cameraStatus.isDenied) {
      // Request camera permission
      cameraStatus = await Permission.camera.request();

      if (cameraStatus.isGranted) {
        final imageFile = await captureImage();
        if (imageFile != null) {
          final imageUrl = await uploadImage(imageFile);
          await sendMediaMessage(imageUrl ?? "",
              textType: 'image'); // Send the message with the image URL
        }
        appPrint("Camera permission granted");
      } else {
        // Permission denied, show dialog to inform the user
        _showPermissionDeniedDialog("Camera");
      }
    } else if (cameraStatus.isPermanentlyDenied) {
      // Permission permanently denied; provide instructions to open settings
      _showOpenSettingsDialog("Camera");
    }*/
  }

  Future<Uint8List?> pickFile() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
      );

      appPrint("File picked: ${result.toString()}");
      if (result != null) {
        // Use the bytes property to access the file data
        return result.files.single.bytes;
      } else {
        // User canceled the picker
        appPrint("No file selected.");
        return null;
      }
    } catch (e) {
      appPrint("Error picking file: $e");
      return null;
    }
  }

  void selectAndUploadFile() async {
    final file = await pickFile();

    if (file != null) {
      appPrint("File Length:::::::::: : ${file.length}");

      final fileUrl = await uploadImage(file);
      if (fileUrl != null) {
        appPrint("File uploaded successfully: $fileUrl");
        await sendMediaMessage(fileUrl, textType: 'image');
      }
    } else {
      appPrint("No file selected");
    }
  }

  AgoraTokenRequestEntity agoraTokenRequestEntity(String chaName)=> AgoraTokenRequestEntity(
    channelName: chaName,
  );

  SendCallRequestEntity sendCallRequestEntity({
    required String fcm,
    required String title,
    required String body,
    required String image,
    required String type,
    required String callerName,
    required String callerImage,
    required String channel,
    required String videoToken,
})=> SendCallRequestEntity(
    token: fcm,
    title: title,
    body: body,
    image: image,
    type: type,
    callerName: callerName,
    callerImage: callerImage,
    channel: channel,
    videoToken: videoToken,
  );

  Future<String?> fetchFcmToken(String userId) async {
    final response = await supabase
        .from('users')
        .select('fcm_token')
        .eq('user_id', userId)
        .single();
    appPrint("Response:::::::::::::::::::: $response");
    if (response == null) {
      // Handle error
      appPrint("Error fetching FCM token: ${response.error?.message}");
      return null;
    }
    return response['fcm_token'] as String?;
  }

  parseAgoraToken(AgoraTokenResponseEntity response) async {
    if (response.token != null && sharedController.customer_id != null) {
      final partnerId = sharedController.customer_id;
      final fcm = await fetchFcmToken(partnerId!);
      requestToCallRequest(
          fcm ?? "",
          response.token ?? "",
          getChannelName(),
      );
    }


  }

  navigateToCallScreen(String channelName, String agoraToken){
    CallModel callModel = CallModel(
      channelName: channelName,
      videoToken: agoraToken,
      isJoin: false,
      callerName: "callerName",
      callerImage: "callerImage",
    );
    appPrint("Navigating to call screen with channel: $channelName");
    appPrint("Navigating to call screen with token: $agoraToken");
    AppRoutes.pushNamed(RoutePath.videoCall, extra: callModel);
  }

  String getChannelName(){
    return generateUniqueString();
  }
  String generateUniqueString() {
// Supported characters
    const String chars =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !#%&()+-:;<=>.?@[\\]^_{|}~";
    final Random random = Random();

    // Generate a random string of 40 characters
    String randomString = List.generate(
      40,
          (index) => chars[random.nextInt(chars.length)],
    ).join();

    // Shortened timestamp (10 digits instead of 13 for brevity)
    String timestamp = DateTime.now().millisecondsSinceEpoch.toString().substring(0, 10);

    // Combine timestamp and random string
    return 'channel';
  }

  void requestForAgoraToken(){
    final channelName = getChannelName();
    final repo = appRepository.requestForAgoraToken(agoraTokenRequestEntity(channelName));
    callService(repo,onSuccess: (token){
      parseAgoraToken(token);
    });
  }

  void requestToCallRequest(String fcm, String agoraToken, String channelName){
    final req = sendCallRequestEntity(
      fcm: fcm,
      title: "Incoming Call",
      body: "Incoming Call",
      image: "https://mdbcdn.b-cdn.net/img/new/avatars/2.webp",
      type: "call",
      callerName: "Abdullah",
      callerImage: "https://mdbcdn.b-cdn.net/img/new/avatars/2.webp",
      channel: channelName,
      videoToken: agoraToken,
    );
    final repo = appRepository.requestToSendCallNotification(req);
    callService(repo,onSuccess: (response){
      navigateToCallScreen(channelName, agoraToken);
    });
  }

  PaginationRequest paginationRequest(int page, int limit){
    return PaginationRequest(
      page: page,
      limit: limit,
    );
  }


  parseMessageTemplates(MessagesTemplatesResponseEntity response){
    templates.value = response.templates ?? [];
    filteredTemplates.value = templates;
  }

  void requestForMessageTemplates(){
    final req = paginationRequest(1, 200);
    final repo = appRepository.requestForMessageTemplates(req);
    callService(repo,onSuccess: (response){
      parseMessageTemplates(response);
    });
  }

}
