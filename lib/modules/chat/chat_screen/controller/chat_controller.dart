// AutoGenerated file for ChatScreenController
// generate date: 16/10/24 08:01 PM
import 'dart:async';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:globipay_admin_panel/core/services/navigator/app_navigator_service.dart';
import 'package:globipay_admin_panel/data/models/call_model.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:globipay_admin_panel/core/base/base_controller.dart';
import 'package:globipay_admin_panel/core/constants/enum/user_type.dart';
import 'package:globipay_admin_panel/core/data/local/repository/token_repository.dart';
import 'package:globipay_admin_panel/core/di/injector.dart';
import 'package:globipay_admin_panel/core/widgets/app_print.dart';
import 'package:globipay_admin_panel/data/services/supabase_service.dart';
import 'package:globipay_admin_panel/entity/response/message/message.dart';
import 'package:globipay_admin_panel/modules/chat/controller/chat_shared_controller.dart';
import 'package:globipay_admin_panel/router/app_routes.dart';
import 'package:globipay_admin_panel/router/route_path.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:storage_client/storage_client.dart';
import 'dart:typed_data';
import 'package:file_picker/file_picker.dart';
/**
 * Created by Abdullah on 16/10/24 08:01 PM.
 */
class ChatController extends BaseController {
  // Variables
  RxList<Message> messages = RxList<Message>([]);
  RxBool isTyping = false.obs;
  final supabase = SupabaseService().client;
  final ChatSharedController sharedController =
      Injector.resolve<ChatSharedController>();
  ScrollController scrollController = ScrollController();

  final TextEditingController messageController = TextEditingController();
  // Constructor
  final TokenRepository tokenRepository;

  ChatController(this.tokenRepository);

  Timer? _typingTimer;
  bool _isTyping = false;

  @override
  void onInit() {
    _initializeMessages();
    _onListener();
    super.onInit();
  }
  void _onListener(){
    messageController.addListener(_onTyping);
  }

  void _initializeMessages() {
    getUserInfo();
    listenForMessages();
    fetchMessagesForSession(sharedController.chatSessionId ?? "");
  }

  //
  Future<void> getUserInfo() async {
    final userId = await tokenRepository.getUserID();
    final response = await supabase
        .from('users')
        .select()
        .eq('user_id', userId)
        .single(); // Use .single() to get a single row result

    if (response != null) {
      appPrint('User::::::::::::::::::: $response');
      // Now you can use userInfo as needed
    } else {
      appPrint('Error fetching user info: ${response.error?.message}');
    }
  }

  // Method to send a text message
  Future<void> sendTextMessage(String text, {String? textType}) async {
    final response = await supabase.from('messages').insert({
      'session_id': sharedController.chatSessionId,
      'sender_id': sharedController.currentUserId,
      'message': text,
      'message_type': textType ?? 'text', // Specify message type
      'status': 'sent', // Initial status
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Admin.name
    }).execute();

    updateLastMessage(
        sessionId: sharedController.chatSessionId ?? "",
        message: text,
        isSeen: false,
        messageType: 'text'
    );
  }

  Future<void> sendMediaMessage(String url, {String? textType}) async {
    final response = await supabase.from('messages').insert({
      'session_id': sharedController.chatSessionId,
      'sender_id': sharedController.currentUserId,
      'message_type': textType ?? 'text',
      'status': 'sent', // Initial status
      'media_url': url,
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Customer.name
    }).execute();


    updateLastMessage(
      sessionId: sharedController.chatSessionId ?? "",
      message: "new image message",
      isSeen: false,
      messageType: 'image'
    );
  }

  // Method to update message status (sent, delivered, seen)
  Future<void> updateMessageStatus(String messageId, String status) async {
    try {
      await supabase
          .from('messages')
          .update({'status': status}).eq('id', messageId);
    } catch (e) {
      print('Error updating message status: $e');
    }
  }

  // Real-time listener for new messages
  void listenForMessages() {
    appPrint('Setting up listener for messages...');

    // Create a channel for the 'messages' table with the public schema, filtered by session_id
    final channel = supabase.channel('public:messages')
      ..on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          // Here we apply the filter for session_id
          filter: 'session_id=eq.${sharedController.chatSessionId}',
        ),
        (payload, [ref]) async {
          if (payload['new'] != null) {
            final newMessage = Message.fromJson(payload['new']);

            // Add the new message to the list
            messages.add(newMessage);

            // Update the UI
            update();

            // Scroll to the bottom of the chat
            scrollToBottom();

            // Optionally, mark the message as delivered if it is for the current user
            if (newMessage.sender_id != sharedController.currentUserId) {
              markMessageAsDelivered(newMessage.id);
            }
          } else {
            appPrint('No new message found in payload: $payload');
          }
        },
      ).subscribe();
  }

  Future<void> markMessageAsDelivered(String? messageId) async {
    try {
      await supabase
          .from('messages')
          .update({
            'status': 'delivered',
            'delivered_at': DateTime.now().toIso8601String(),
          })
          .eq('id', messageId)
          .execute();
    } catch (e) {
      print('Error marking message as delivered: $e');
    }
  }

  Future<void> markMessageAsSeen(int messageId) async {
    try {
      await supabase
          .from('messages')
          .update({
            'status': 'seen',
            'seen_at': DateTime.now().toIso8601String(),
          })
          .eq('id', messageId)
          .execute();
    } catch (e) {
      print('Error marking message as seen: $e');
    }
  }

  Future<void> updateTypingStatus(bool isTyping) async {

    final sessionId = sharedController.chatSessionId;
    if (sessionId == null) {
      return;
    }

    appPrint('Updating typing status: $isTyping');

    final loggedInUserId = await tokenRepository.getUserID();


    final isSender = loggedInUserId == sharedController.customer_id;
    final field = isSender ? 'is_sender_typing' : 'is_receiver_typing';
    await supabase
        .from('chat_sessions')
        .update({field: isTyping}).eq('session_id', sessionId);
  }

  Future<void> updateLastMessage({
    required String sessionId,
    required String message,
    required bool isSeen,
    required String messageType,
  }) async {
    await supabase.from('chat_sessions').update({
      'last_message': message,
      'last_message_timestamp': DateTime.now().toIso8601String(),
      'is_last_message_seen': isSeen,
      'message_type' : messageType
    }).eq('session_id', sessionId);
  }

  Future<void> markLastMessageAsSeen(String sessionId) async {
    await supabase
        .from('chat_sessions')
        .update({'is_last_message_seen': true}).eq('session_id', sessionId);
  }

  // Mark messages as seen
  Future<void> markMessagesAsSeen() async {
    try {
      await supabase
          .from('messages')
          .update({'status': 'seen'})
          .eq('receiver_id', sharedController.currentUserId)
          .eq('sender_id', sharedController.chatPartnerId)
          .eq('status', 'delivered');
    } catch (e) {
      print('Error marking messages as seen: $e');
    }
  }

  // Search messages by keyword
  Future<List<Message>> searchMessages(String keyword) async {
    try {
      final response = await supabase
          .from('messages')
          .select()
          .ilike('message', '%$keyword%')
          .eq('sender_id', sharedController.currentUserId)
          .or('receiver_id.eq.${sharedController.chatPartnerId}, sender_id.eq.${sharedController.chatPartnerId}');

      return (response.data as List)
          .map((data) => Message.fromJson(data))
          .toList();
    } catch (e) {
      print('Error searching messages: $e');
      return [];
    }
  }

  // Delete a message (Soft Delete - Update status to 'deleted')
  Future<void> deleteMessage(String messageId) async {
    try {
      await supabase
          .from('Messages')
          .update({'status': 'deleted'}).eq('id', messageId);
    } catch (e) {
      print('Error deleting message: $e');
    }
  }

  // Send push notification
  Future<void> sendPushNotification(String title, String body) async {
    // Use Firebase Cloud Messaging or any push service
  }

  Future<String> uploadMediaFile(File file, String folder) async {
    return "";
    /*final fileName =
        '${DateTime.now().millisecondsSinceEpoch}_${file.path.split('/').last}';
    final response = await supabase.storage.from(folder).upload(fileName, file);
    if (response == null) {
      return supabase.storage.from(folder).getPublicUrl(fileName);
    } else {
      throw Exception("Failed to upload file");
    }*/
  }

  //Load all messages

  void fetchMessagesForSession(String sessionId) async {
    try {
      // Fetch messages for the specified session ID
      final response = await supabase
          .from('messages')
          .select('*') // Select all columns or specify the ones you need
          .eq('session_id', sessionId)
          .order('created_at', ascending: true)
          .execute();

      if (response.data == null) {
        throw Exception('Failed to fetch messages: ${response.data}');
      }

      // Parse the response to your message entity
      final messagesList = (response.data as List)
          .map((item) => Message.fromJson(item))
          .toList();

      // Set the fetched messages to your message list or state variable
      messages.value = messagesList;

      appPrint(
          'Fetched ${messagesList.length} messages for session $sessionId');
    } catch (e) {
      print('Exception while loading messages: $e');
    }
  }

  void scrollToBottom() {
    Future.delayed(const Duration(milliseconds: 100), () {
      scrollController.jumpTo(scrollController.position.maxScrollExtent);
    });
  }

  void _onTyping() {
    if (!_isTyping) {
      _isTyping = true;
      updateTypingStatus(true); // User started typing
    }

    // Cancel the previous timer and start a new one
    _typingTimer?.cancel();
    _typingTimer = Timer(const Duration(seconds: 2), () {
      _isTyping = false;
      updateTypingStatus(false); // User stopped typing
    });
  }

  void onAudioCall() {
    //AppRoutes.pushNamed(RoutePath.audioCall);
   // AppRoutes.pushNamed(RoutePath.callPickUp);
    // show a snack bar of Upcoming feature

    SnackBar snackBar = SnackBar(
      content: Text("Upcoming feature"),
      backgroundColor: Colors.green,
    );
    ScaffoldMessenger.of(AppNavigatorService.navigatorKey.currentState!.context).showSnackBar(snackBar);
  }

  void onVideoCall() {

    // Send FCM notification to the other user
    // Navigate to Video call screen and start the call

    String channelName = 'globi_pay';
    String agoraToken = '007eJxTYDhot18rpzUr94TyawGelTuqn2yp2XnqlD9/LtPybqM9exsUGNIsDCySTCyTkhPNTU2SLSwSEw2TE5MsUwzSks0tLJNTubvM01eLWaSnB25nYmRgZGABYhBgApPMYJIFTHIypOfkJ2XGFyRWMjAAAD2vIao=';


    CallModel callModel = CallModel(
      channelName: channelName,
      videoToken: agoraToken,
      isJoin: false,
      callerName: "callerName",
      callerImage: "callerImage",
    );
    AppRoutes.pushNamed(RoutePath.videoCall, extra: callModel);
  }

  // Image Message



  void onSendMessageUsingCamera() {
    requestCameraPermission();
  }

  void onSendMessageFromPhotoLibrary() async {
    selectAndUploadFile();
  }


  void selectAndUploadImage() async {
    final Uint8List? imageBytes = await pickImageFromGallery();

    if (imageBytes != null) {
      final String? imageUrl = await uploadImage(imageBytes);
      if (imageUrl != null) {
        await sendMediaMessage(imageUrl, textType: 'image');
      } else {
        appPrint("Failed to upload the image.");
      }
    } else {
      appPrint("No image selected");
    }
  }

// Function to pick an image from the gallery
  Future<Uint8List?> pickImageFromGallery() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
      );

      if (result != null) {
        return result.files.single.bytes; // Return the image bytes
      }
    } catch (e) {
      appPrint("Error picking image: $e");
    }

    return null;
  }

  Future<String?> uploadImage(Uint8List imageFile) async {
    try {
      final supabase = Supabase.instance.client;

      // Define a unique file name for the image
      final String fileName =
          'images/${DateTime.now().millisecondsSinceEpoch}.png';

      // Upload the file to Supabase storage
      final  response = await supabase.storage.from('chats').uploadBinary(
        fileName,
        imageFile,
        fileOptions: FileOptions(contentType: 'image/png'), // Set MIME type for PNG
      );

      // Check if the upload was successful
      if (response != null) {
        // Get the public URL of the uploaded image
        final String publicUrl = supabase.storage.from('chats').getPublicUrl(fileName);
        return publicUrl; // Return the URL of the uploaded image
      } else {
        print('Image upload failed: ${response}');
        return null;
      }
    } catch (e) {
      print('Error uploading image: $e');
      return null;
    }
  }






  void _showPermissionDeniedDialog(String permission) {
    showDialog(
      context: AppNavigatorService.navigatorKey.currentState!.context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text("$permission Permission Denied"),
          content: Text(
              "This app requires $permission permission to access the photo library. Please grant it in the settings."),
          actions: [
            TextButton(
              child: Text("OK"),
              onPressed: () {
                AppRoutes.pop();
              },
            ),
          ],
        );
      },
    );
  }

  void _showOpenSettingsDialog(String permission) {
    showDialog(
      context: AppNavigatorService.navigatorKey.currentState!.context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text("$permission Permission Denied Permanently"),
          content: Text(
              "To use this feature, you need to enable $permission permission in the app settings."),
          actions: [
            TextButton(
              child: Text("Open Settings"),
              onPressed: () {
                openAppSettings(); // Opens the app settings for the user
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text("Cancel"),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }

  // Camera Related stuffs
  void requestCameraPermission() async {
    // Check the current permission status
    /*var cameraStatus = await Permission.camera.status;

    if (cameraStatus.isGranted) {
      // Permission already granted, open the camera
      final imageFile =
          await captureImage(); // Add your camera image capture logic here
      if (imageFile != null) {
        final imageUrl = await uploadImage(imageFile);
        await sendMediaMessage(imageUrl ?? "",
            textType: 'image'); // Send the message with the image URL
      }
      appPrint("Camera permission granted");
    } else if (cameraStatus.isDenied) {
      // Request camera permission
      cameraStatus = await Permission.camera.request();

      if (cameraStatus.isGranted) {
        final imageFile = await captureImage();
        if (imageFile != null) {
          final imageUrl = await uploadImage(imageFile);
          await sendMediaMessage(imageUrl ?? "",
              textType: 'image'); // Send the message with the image URL
        }
        appPrint("Camera permission granted");
      } else {
        // Permission denied, show dialog to inform the user
        _showPermissionDeniedDialog("Camera");
      }
    } else if (cameraStatus.isPermanentlyDenied) {
      // Permission permanently denied; provide instructions to open settings
      _showOpenSettingsDialog("Camera");
    }*/
  }

  /*Future<File?> captureImage() async {
    final picker = ImagePicker();

    // Open the camera to capture an image
    final pickedFile = await picker.pickImage(
      source: ImageSource.camera,
      maxWidth: 1024,
      maxHeight: 1024,
      imageQuality: 85, // Compress the image for upload efficiency
    );

    if (pickedFile != null) {
      return File(pickedFile.path); // Return the captured image as a File
    }

    return null; // Return null if no image is captured
  }*/

/*Future<String?> uploadImage(File imageFile) async {
    try {
      final supabase = Supabase.instance.client;

      // Define the unique file name for the image
      final fileName =
          'images/${DateTime.now().millisecondsSinceEpoch}_${imageFile.path.split('/').last}';

      // Upload the file to Supabase storage
      final response = await supabase.storage.from('chats').upload(
            fileName,
            imageFile,
          );

      // Check if the upload was successful
      if (response != null) {
        // Get the public URL of the uploaded image
        final publicUrl = supabase.storage.from('chats').getPublicUrl(fileName);
        return publicUrl; // Return the URL of the uploaded image
      } else {
        print('Image upload failed: ${response}');
        return null;
      }
    } catch (e) {
      print('Error uploading image: $e');
      return null;
    }
  }*/

  Future<Uint8List?> pickFile() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
      );

      if (result != null) {
        // Use the bytes property to access the file data
        return result.files.single.bytes;
      } else {
        // User canceled the picker
        print("No file selected.");
        return null;
      }
    } catch (e) {
      print("Error picking file: $e");
      return null;
    }
  }

  void selectAndUploadFile() async {
    final file = await pickFile();

    /*if (file != null) {
      final fileUrl = await uploadImage(file);
      if (fileUrl != null) {
        appPrint("File uploaded successfully: $fileUrl");
        await sendMediaMessage(fileUrl, textType: 'image');
      }
    } else {
      appPrint("No file selected");
    }*/
  }


}
