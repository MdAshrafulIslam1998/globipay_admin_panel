// AutoGenerated file for ChatScreenController
// generate date: 16/10/24 08:01 PM
import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/services.dart';
import 'package:globipay_admin_panel/core/constants/enum/chat_session_type.dart';
import 'package:globipay_admin_panel/core/data/model/pagination_request.dart';
import 'package:globipay_admin_panel/core/services/navigator/app_navigator_service.dart';
import 'package:globipay_admin_panel/core/utils/custom_dialog.dart';
import 'package:globipay_admin_panel/core/utils/inputFilter/input_filter.dart';
import 'package:globipay_admin_panel/core/widgets/text_filed/input_field.dart';
import 'package:globipay_admin_panel/core/widgets/text_filed/input_regex.dart';
import 'package:globipay_admin_panel/data/models/call_model.dart';
import 'package:globipay_admin_panel/data/repository/app_repository.dart';
import 'package:globipay_admin_panel/entity/request/agora/agora_token_request_entity.dart';
import 'package:globipay_admin_panel/entity/request/call/send_call_request_entity.dart';
import 'package:globipay_admin_panel/entity/request/chat_close/chat_close_request_entity.dart';
import 'package:globipay_admin_panel/entity/response/agora/agora_token_response_entity.dart';
import 'package:globipay_admin_panel/entity/response/chat_close/chat_close_response_entity.dart';
import 'package:globipay_admin_panel/entity/response/messages_templates/message_templates_item_entity.dart';
import 'package:globipay_admin_panel/entity/response/messages_templates/messages_templates_response_entity.dart';
import 'package:globipay_admin_panel/modules/chat/chat_screen/views/message_templates_view.dart';
import 'package:globipay_admin_panel/modules/chat/chat_screen/views/widgets/chat_close_dialog.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:globipay_admin_panel/core/base/base_controller.dart';
import 'package:globipay_admin_panel/core/constants/enum/user_type.dart';
import 'package:globipay_admin_panel/core/data/local/repository/token_repository.dart';
import 'package:globipay_admin_panel/core/di/injector.dart';
import 'package:globipay_admin_panel/core/widgets/app_print.dart';
import 'package:globipay_admin_panel/data/services/supabase_service.dart';
import 'package:globipay_admin_panel/entity/response/message/message.dart';
import 'package:globipay_admin_panel/modules/chat/controller/chat_shared_controller.dart';
import 'package:globipay_admin_panel/router/app_routes.dart';
import 'package:globipay_admin_panel/router/route_path.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:storage_client/storage_client.dart';
import 'dart:typed_data';
import 'package:file_picker/file_picker.dart';
import 'dart:html' as html;

/**
 * Created by Abdullah on 16/10/24 08:01 PM.
 */
class ChatController extends BaseController {
  // Variables
  RxList<Message> messages = RxList<Message>([]);
  RxBool isTyping = false.obs;
  final supabase = SupabaseService().client;
  final ChatSharedController sharedController =
      Injector.resolve<ChatSharedController>();
  ScrollController scrollController = ScrollController();

  final TextEditingController messageController = TextEditingController();
  TextEditingController primaryCoinController = TextEditingController();
  TextEditingController secondaryCoinController = TextEditingController();


  // Constructor
  final TokenRepository tokenRepository;
  final AppRepository appRepository;

  ChatController(this.tokenRepository,this.appRepository);

  GlobalKey<FormState> chatCloseFormKey = GlobalKey<FormState>();
  Timer? _typingTimer;
  bool _isTyping = false;
  var templates =  <MessageTemplatesItemEntity>[].obs; // Your list of templates
  var showTemplates = false.obs; // Controls the split view

  final ValueNotifier<List<MessageTemplatesItemEntity>> filteredTemplates = ValueNotifier<List<MessageTemplatesItemEntity>>([]);
  final ValueNotifier<String> selectedCategory = ValueNotifier<String>('All');
  String searchQuery = '';

  @override
  void onInit() {
    fetchTemplates();
    _initializeMessages();
    _onListener();
    super.onInit();
  }
  // Get unique categories from templates
  List<String> getUniqueCategories() {
    return templates
        .map((template) => template.category_name ?? "")
        .where((category) => category.isNotEmpty) // Filter out empty strings
        .toSet()
        .toList()
      ..sort();
  }

  bool isChatSessionClosed() {
    return sharedController.chatSessionResponse?.status == ChatSessionType.CLOSED.code;
  }


  // Handle category selection
  void onCategorySelected(String category) {
    selectedCategory.value = category;
    _applyFilters();
  }

  // Handle search text changes
  void onSearchChanged(String query) {
    searchQuery = query;
    _applyFilters();
  }

  // Apply both category and search filters
  void _applyFilters() {
    List<MessageTemplatesItemEntity> result = List.from(templates);

    // Apply category filter
    if (selectedCategory.value != 'All') {
      result = result.where((template) =>
      template.category_name == selectedCategory.value).toList();
    }

    // Apply search filter
    if (searchQuery.isNotEmpty) {
      result = result.where((template) =>
      (template.title??"").toLowerCase().contains(searchQuery.toLowerCase()) ||
          (template.description ?? "").toLowerCase().contains(searchQuery.toLowerCase()) ||
          (template.category_name ??"").toLowerCase().contains(searchQuery.toLowerCase())
      ).toList();
    }

    filteredTemplates.value = result;
  }


  void fetchTemplates() {
    requestForMessageTemplates();
  }

  void searchTemplates(String query) {
    if (query.isEmpty) {
      filteredTemplates.value = templates;
      return;
    }

    filteredTemplates.value = templates
        .where((template) =>
    (template.title ??"").toLowerCase().contains(query.toLowerCase()) ||
        (template.description ?? "").toLowerCase().contains(query.toLowerCase()) ||
        (template.category_name ?? "").toLowerCase().contains(query.toLowerCase()))
        .toList();
  }

  
  void onTemplateSelected(String template) {
    messageController.text = template;
    messageController.selection = TextSelection.fromPosition(
        TextPosition(offset: messageController.text.length));
  }

  void _onListener(){
    messageController.addListener(_onTyping);
  }

  void _initializeMessages() {
    getUserInfo();
    listenForMessages();
    fetchMessagesForSession(sharedController.chatSessionId ?? "");
  }

  //
  Future<void> getUserInfo() async {
    final userId = await tokenRepository.getUserID();
    final response = await supabase
        .from('users')
        .select()
        .eq('user_id', userId)
        .single(); // Use .single() to get a single row result

    if (response != null) {
      appPrint('User::::::::::::::::::: $response');
      // Now you can use userInfo as needed
    } else {
      appPrint('Error fetching user info: ${response.error?.message}');
    }
  }

  // Method to send a text message
  Future<void> sendTextMessage(String text, {String? textType}) async {
    final response = await supabase.from('messages').insert({
      'session_id': sharedController.chatSessionId,
      'sender_id': sharedController.currentUserId,
      'message': text,
      'message_type': textType ?? 'text', // Specify message type
      'status': 'sent', // Initial status
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Admin.name
    }).execute();

    updateLastMessage(
        sessionId: sharedController.chatSessionId ?? "",
        message: text,
        isSeen: false,
        messageType: 'text'
    );
  }

  Future<void> sendMediaMessage(String url, {String? textType}) async {
    final response = await supabase.from('messages').insert({
      'session_id': sharedController.chatSessionId,
      'sender_id': sharedController.currentUserId,
      'message_type': textType ?? 'text',
      'status': 'sent', // Initial status
      'media_url': url,
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Customer.name
    }).execute();


    updateLastMessage(
      sessionId: sharedController.chatSessionId ?? "",
      message: "new image message",
      isSeen: false,
      messageType: 'image'
    );
  }

  // Method to update message status (sent, delivered, seen)
  Future<void> updateMessageStatus(String messageId, String status) async {
    try {
      await supabase
          .from('messages')
          .update({'status': status}).eq('id', messageId);
    } catch (e) {
      print('Error updating message status: $e');
    }
  }

  // Real-time listener for new messages
  void listenForMessages() {
    appPrint('Setting up listener for messages...');

    // Create a channel for the 'messages' table with the public schema, filtered by session_id
    final channel = supabase.channel('public:messages')
      ..on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          // Here we apply the filter for session_id
          filter: 'session_id=eq.${sharedController.chatSessionId}',
        ),
        (payload, [ref]) async {
          if (payload['new'] != null) {
            final newMessage = Message.fromJson(payload['new']);

            // Add the new message to the list
            messages.add(newMessage);

            // Update the UI
            update();

            // Scroll to the bottom of the chat
            scrollToBottom();

            // Optionally, mark the message as delivered if it is for the current user
            if (newMessage.sender_id != sharedController.currentUserId) {
              markMessageAsDelivered(newMessage.id);
            }
          } else {
            appPrint('No new message found in payload: $payload');
          }
        },
      ).subscribe();
  }

  Future<void> markMessageAsDelivered(String? messageId) async {
    try {
      await supabase
          .from('messages')
          .update({
            'status': 'delivered',
            'delivered_at': DateTime.now().toIso8601String(),
          })
          .eq('id', messageId)
          .execute();
    } catch (e) {
      print('Error marking message as delivered: $e');
    }
  }

  Future<void> markMessageAsSeen(int messageId) async {
    try {
      await supabase
          .from('messages')
          .update({
            'status': 'seen',
            'seen_at': DateTime.now().toIso8601String(),
          })
          .eq('id', messageId)
          .execute();
    } catch (e) {
      print('Error marking message as seen: $e');
    }
  }

  Future<void> updateTypingStatus(bool isTyping) async {

    final sessionId = sharedController.chatSessionId;
    if (sessionId == null) {
      return;
    }

    appPrint('Updating typing status: $isTyping');

    final loggedInUserId = await tokenRepository.getUserID();


    final isSender = loggedInUserId == sharedController.customer_id;
    final field = isSender ? 'is_sender_typing' : 'is_receiver_typing';
    await supabase
        .from('chat_sessions')
        .update({field: isTyping}).eq('session_id', sessionId);
  }

  Future<void> updateLastMessage({
    required String sessionId,
    required String message,
    required bool isSeen,
    required String messageType,
  }) async {
    await supabase.from('chat_sessions').update({
      'last_message': message,
      'last_message_timestamp': DateTime.now().toIso8601String(),
      'is_last_message_seen': isSeen,
      'message_type' : messageType
    }).eq('session_id', sessionId);
  }

  Future<void> markLastMessageAsSeen(String sessionId) async {
    await supabase
        .from('chat_sessions')
        .update({'is_last_message_seen': true}).eq('session_id', sessionId);
  }

  // Mark messages as seen
  Future<void> markMessagesAsSeen() async {
    try {
      await supabase
          .from('messages')
          .update({'status': 'seen'})
          .eq('receiver_id', sharedController.currentUserId)
          .eq('sender_id', sharedController.chatPartnerId)
          .eq('status', 'delivered');
    } catch (e) {
      print('Error marking messages as seen: $e');
    }
  }

  // Search messages by keyword
  Future<List<Message>> searchMessages(String keyword) async {
    try {
      final response = await supabase
          .from('messages')
          .select()
          .ilike('message', '%$keyword%')
          .eq('sender_id', sharedController.currentUserId)
          .or('receiver_id.eq.${sharedController.chatPartnerId}, sender_id.eq.${sharedController.chatPartnerId}');

      return (response.data as List)
          .map((data) => Message.fromJson(data))
          .toList();
    } catch (e) {
      print('Error searching messages: $e');
      return [];
    }
  }

  // Delete a message (Soft Delete - Update status to 'deleted')
  Future<void> deleteMessage(String messageId) async {
    try {
      await supabase
          .from('Messages')
          .update({'status': 'deleted'}).eq('id', messageId);
    } catch (e) {
      print('Error deleting message: $e');
    }
  }

  // Send push notification
  Future<void> sendPushNotification(String title, String body) async {
    // Use Firebase Cloud Messaging or any push service
  }

  Future<String> uploadMediaFile(File file, String folder) async {
    return "";
    /*final fileName =
        '${DateTime.now().millisecondsSinceEpoch}_${file.path.split('/').last}';
    final response = await supabase.storage.from(folder).upload(fileName, file);
    if (response == null) {
      return supabase.storage.from(folder).getPublicUrl(fileName);
    } else {
      throw Exception("Failed to upload file");
    }*/
  }

  //Load all messages

  void fetchMessagesForSession(String sessionId) async {
    try {
      // Fetch messages for the specified session ID
      final response = await supabase
          .from('messages')
          .select('*') // Select all columns or specify the ones you need
          .eq('session_id', sessionId)
          .order('created_at', ascending: true)
          .execute();

      if (response.data == null) {
        throw Exception('Failed to fetch messages: ${response.data}');
      }

      // Parse the response to your message entity
      final messagesList = (response.data as List)
          .map((item) => Message.fromJson(item))
          .toList();

      // Set the fetched messages to your message list or state variable
      messages.value = messagesList;

      appPrint(
          'Fetched ${messagesList.length} messages for session $sessionId');
    } catch (e) {
      print('Exception while loading messages: $e');
    }
  }

  void scrollToBottom() {
    Future.delayed(const Duration(milliseconds: 100), () {
      scrollController.jumpTo(scrollController.position.maxScrollExtent);
    });
  }

  void _onTyping() {
    if (!_isTyping) {
      _isTyping = true;
      updateTypingStatus(true); // User started typing
    }

    // Cancel the previous timer and start a new one
    _typingTimer?.cancel();
    _typingTimer = Timer(const Duration(seconds: 2), () {
      _isTyping = false;
      updateTypingStatus(false); // User stopped typing
    });
  }

  void onAudioCall() {
    //AppRoutes.pushNamed(RoutePath.audioCall);
   // AppRoutes.pushNamed(RoutePath.callPickUp);
    // show a snack bar of Upcoming feature

    SnackBar snackBar = SnackBar(
      content: Text("Upcoming feature"),
      backgroundColor: Colors.green,
    );
    ScaffoldMessenger.of(AppNavigatorService.navigatorKey.currentState!.context).showSnackBar(snackBar);
  }

  Future<void> onVideoCall() async {
    requestForAgoraToken();
  }


  void onChatClose(BuildContext context) {


    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {


        return AlertDialog(
          title: Text("Close Chat"),
          content: Form(
            key: chatCloseFormKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Primary Coin Input Field
                InputField(
                  controller: primaryCoinController,
                  regex: InputRegex.NOT_EMPTY,
                  inputFormatters: InputFilter.AMOUNT_INPUT_FILTER,
                  hintText: "Primary Coin",

                ),
                SizedBox(height: 10),
                // Secondary Coin Input Field
                InputField(
                  controller: secondaryCoinController,
                  regex: InputRegex.NOT_EMPTY,
                  maxLength: 10,
                  inputFormatters: InputFilter.AMOUNT_INPUT_FILTER,
                  hintText: "Secondary Coin",

                ),
              ],
            ),
          ),
          actions: [
            // Cancel Button
            TextButton(
              onPressed: () {
                AppRoutes.pop();
              },
              child: Text("Cancel"),
            ),
            // Submit Button
            ElevatedButton(
              onPressed: () {
                if (chatCloseFormKey.currentState!.validate()) {
                  AppRoutes.pop();
                  requestToCloseChatSession();
                }
              },
              child: Text("Submit"),
            ),
          ],
        );
      },
    );
  }

  ChatCloseRequestEntity chatCloseRequestEntity(String createdById){
    return ChatCloseRequestEntity(
      primaryCoin: primaryCoinController.text.isNotEmpty ? double.tryParse(primaryCoinController.text) : 0.0,
      secondaryCoin: secondaryCoinController.text.isNotEmpty ? double.tryParse(secondaryCoinController.text) : 0.0,
      catId: int.tryParse(sharedController.chatSessionResponse?.category ?? "-1"),
      uid: sharedController.chatSessionResponse?.customer_id ?? "",
      createdBy: createdById,
    );
  }

  requestToCloseChatSession() async{
    final cId = await getLoggedInUserId();
    final req = chatCloseRequestEntity(cId);
    final repo = appRepository.requestToCloseChat(req);
    callService(repo,onSuccess: (ChatCloseResponseEntity response){
      parseChatCloseSession(response);
    });
  }

  parseChatCloseSession(ChatCloseResponseEntity response){
    updateSupabaseChatSession();
  }

  updateSupabaseChatSession() async{

    // Update the chat session status to closed
    try {
      await supabase.from('chat_sessions').update({
        'status': 'closed',
        'closed_at': DateTime.now().toIso8601String(),
      }).eq('session_id', sharedController.chatSessionId).execute();
    } catch (e) {
      print('Error closing chat session: $e');
    }
    showCustomDialog(
      "Chat session closed successfully : ${sharedController.chatSessionId}",
      positiveButtonText: "Ok",
      positiveButtonAction: (){
        AppRoutes.pop();
      }
    );

  }

  void onSendMessageFromPhotoLibrary() async {
    selectAndUploadFile();
  }


  void selectAndUploadImage() async {
    final Uint8List? imageBytes = await pickImageFromGallery();

    if (imageBytes != null) {
      final String? imageUrl = await uploadImage(imageBytes);
      if (imageUrl != null) {
        await sendMediaMessage(imageUrl, textType: 'image');
      } else {
        appPrint("Failed to upload the image.");
      }
    } else {
      appPrint("No image selected");
    }
  }

// Function to pick an image from the gallery
  Future<Uint8List?> pickImageFromGallery() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
      );

      if (result != null) {
        return result.files.single.bytes; // Return the image bytes
      }
    } catch (e) {
      appPrint("Error picking image: $e");
    }

    return null;
  }

  Future<String?> uploadImage(Uint8List imageFile) async {
    try {
      // Define a unique file name for the image
      final String fileName =
          'images/${DateTime.now().millisecondsSinceEpoch}.png';

      // Upload the file to Supabase storage
      final  response = await supabase.storage.from('chats').uploadBinary(
        fileName,
        imageFile,
        fileOptions: FileOptions(contentType: 'image/png'), // Set MIME type for PNG
      );

      // Check if the upload was successful
      if (response != null) {
        // Get the public URL of the uploaded image
        final String publicUrl = supabase.storage.from('chats').getPublicUrl(fileName);
        return publicUrl; // Return the URL of the uploaded image
      } else {
        appPrint('Image upload failed: ${response}');
        return null;
      }
    } catch (e) {
      print('Error uploading image: $e');
      return null;
    }
  }

  void _showPermissionDeniedDialog(String permission) {
    showDialog(
      context: AppNavigatorService.navigatorKey.currentState!.context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text("$permission Permission Denied"),
          content: Text(
              "This app requires $permission permission to access the photo library. Please grant it in the settings."),
          actions: [
            TextButton(
              child: Text("OK"),
              onPressed: () {
                AppRoutes.pop();
              },
            ),
          ],
        );
      },
    );
  }

  void _showOpenSettingsDialog(String permission) {
    showDialog(
      context: AppNavigatorService.navigatorKey.currentState!.context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text("$permission Permission Denied Permanently"),
          content: Text(
              "To use this feature, you need to enable $permission permission in the app settings."),
          actions: [
            TextButton(
              child: Text("Open Settings"),
              onPressed: () {
                openAppSettings(); // Opens the app settings for the user
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text("Cancel"),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }

  // Camera Related stuffs
  void requestCameraPermission() async {
    // Check the current permission status
    /*var cameraStatus = await Permission.camera.status;

    if (cameraStatus.isGranted) {
      // Permission already granted, open the camera
      final imageFile =
          await captureImage(); // Add your camera image capture logic here
      if (imageFile != null) {
        final imageUrl = await uploadImage(imageFile);
        await sendMediaMessage(imageUrl ?? "",
            textType: 'image'); // Send the message with the image URL
      }
      appPrint("Camera permission granted");
    } else if (cameraStatus.isDenied) {
      // Request camera permission
      cameraStatus = await Permission.camera.request();

      if (cameraStatus.isGranted) {
        final imageFile = await captureImage();
        if (imageFile != null) {
          final imageUrl = await uploadImage(imageFile);
          await sendMediaMessage(imageUrl ?? "",
              textType: 'image'); // Send the message with the image URL
        }
        appPrint("Camera permission granted");
      } else {
        // Permission denied, show dialog to inform the user
        _showPermissionDeniedDialog("Camera");
      }
    } else if (cameraStatus.isPermanentlyDenied) {
      // Permission permanently denied; provide instructions to open settings
      _showOpenSettingsDialog("Camera");
    }*/
  }

  /*Future<File?> captureImage() async {
    final picker = ImagePicker();

    // Open the camera to capture an image
    final pickedFile = await picker.pickImage(
      source: ImageSource.camera,
      maxWidth: 1024,
      maxHeight: 1024,
      imageQuality: 85, // Compress the image for upload efficiency
    );

    if (pickedFile != null) {
      return File(pickedFile.path); // Return the captured image as a File
    }

    return null; // Return null if no image is captured
  }*/

/*Future<String?> uploadImage(File imageFile) async {
    try {
      final supabase = Supabase.instance.client;

      // Define the unique file name for the image
      final fileName =
          'images/${DateTime.now().millisecondsSinceEpoch}_${imageFile.path.split('/').last}';

      // Upload the file to Supabase storage
      final response = await supabase.storage.from('chats').upload(
            fileName,
            imageFile,
          );

      // Check if the upload was successful
      if (response != null) {
        // Get the public URL of the uploaded image
        final publicUrl = supabase.storage.from('chats').getPublicUrl(fileName);
        return publicUrl; // Return the URL of the uploaded image
      } else {
        print('Image upload failed: ${response}');
        return null;
      }
    } catch (e) {
      print('Error uploading image: $e');
      return null;
    }
  }*/

  Future<Uint8List?> pickFile() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
      );

      appPrint("File picked: ${result.toString()}");
      if (result != null) {
        // Use the bytes property to access the file data
        return result.files.single.bytes;
      } else {
        // User canceled the picker
        appPrint("No file selected.");
        return null;
      }
    } catch (e) {
      appPrint("Error picking file: $e");
      return null;
    }
  }

  void selectAndUploadFile() async {
    final file = await pickFile();

    if (file != null) {
      appPrint("File Length:::::::::: : ${file.length}");

      final fileUrl = await uploadImage(file);
      if (fileUrl != null) {
        appPrint("File uploaded successfully: $fileUrl");
        await sendMediaMessage(fileUrl, textType: 'image');
      }
    } else {
      appPrint("No file selected");
    }
  }

  AgoraTokenRequestEntity agoraTokenRequestEntity(String chaName)=> AgoraTokenRequestEntity(
    channelName: chaName,
  );

  SendCallRequestEntity sendCallRequestEntity({
    required String fcm,
    required String title,
    required String body,
    required String image,
    required String type,
    required String callerName,
    required String callerImage,
    required String channel,
    required String videoToken,
})=> SendCallRequestEntity(
    token: fcm,
    title: title,
    body: body,
    image: image,
    type: type,
    callerName: callerName,
    callerImage: callerImage,
    channel: channel,
    videoToken: videoToken,
  );

  Future<String?> fetchFcmToken(String userId) async {
    final response = await supabase
        .from('users')
        .select('fcm_token')
        .eq('user_id', userId)
        .single();
    appPrint("Response:::::::::::::::::::: $response");
    if (response == null) {
      // Handle error
      appPrint("Error fetching FCM token: ${response.error?.message}");
      return null;
    }
    return response['fcm_token'] as String?;
  }

  parseAgoraToken(AgoraTokenResponseEntity response) async {
    if (response.token != null && sharedController.customer_id != null) {
      final partnerId = sharedController.customer_id;
      final fcm = await fetchFcmToken(partnerId!);
      requestToCallRequest(
          fcm ?? "",
          response.token ?? "",
          getChannelName(),
      );
    }


  }

  navigateToCallScreen(String channelName, String agoraToken){
    CallModel callModel = CallModel(
      channelName: channelName,
      videoToken: agoraToken,
      isJoin: false,
      callerName: "callerName",
      callerImage: "callerImage",
    );
    appPrint("Navigating to call screen with channel: $channelName");
    appPrint("Navigating to call screen with token: $agoraToken");
    AppRoutes.pushNamed(RoutePath.videoCall, extra: callModel);
  }

  String getChannelName(){
    return generateUniqueString();
  }
  String generateUniqueString() {
// Supported characters
    const String chars =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !#%&()+-:;<=>.?@[\\]^_{|}~";
    final Random random = Random();

    // Generate a random string of 40 characters
    String randomString = List.generate(
      40,
          (index) => chars[random.nextInt(chars.length)],
    ).join();

    // Shortened timestamp (10 digits instead of 13 for brevity)
    String timestamp = DateTime.now().millisecondsSinceEpoch.toString().substring(0, 10);

    // Combine timestamp and random string
    return 'channel';
  }

  void requestForAgoraToken(){
    final channelName = getChannelName();
    final repo = appRepository.requestForAgoraToken(agoraTokenRequestEntity(channelName));
    callService(repo,onSuccess: (token){
      parseAgoraToken(token);
    });
  }

  void requestToCallRequest(String fcm, String agoraToken, String channelName){
    final req = sendCallRequestEntity(
      fcm: fcm,
      title: "Incoming Call",
      body: "Incoming Call",
      image: "https://mdbcdn.b-cdn.net/img/new/avatars/2.webp",
      type: "call",
      callerName: "Abdullah",
      callerImage: "https://mdbcdn.b-cdn.net/img/new/avatars/2.webp",
      channel: channelName,
      videoToken: agoraToken,
    );
    final repo = appRepository.requestToSendCallNotification(req);
    callService(repo,onSuccess: (response){
      navigateToCallScreen(channelName, agoraToken);
    });
  }

  PaginationRequest paginationRequest(int page, int limit){
    return PaginationRequest(
      page: page,
      limit: limit,
    );
  }


  parseMessageTemplates(MessagesTemplatesResponseEntity response){
    templates.value = response.templates ?? [];
    filteredTemplates.value = templates;
  }

  void requestForMessageTemplates(){
    final req = paginationRequest(1, 200);
    final repo = appRepository.requestForMessageTemplates(req);
    callService(repo,onSuccess: (response){
      parseMessageTemplates(response);
    });
  }

}
