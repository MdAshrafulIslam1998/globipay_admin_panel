// AutoGenerated file for ChatMessageController
// generate date: 16/10/24 08:01 PM
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:globipay_admin_panel/core/base/base_controller.dart';
import 'package:globipay_admin_panel/core/constants/app_spaces.dart';
import 'package:globipay_admin_panel/core/constants/enum/user_type.dart';
import 'package:globipay_admin_panel/core/data/local/repository/token_repository.dart';
import 'package:globipay_admin_panel/core/data/model/pagination_request.dart';
import 'package:globipay_admin_panel/core/di/injector.dart';
import 'package:globipay_admin_panel/core/services/navigator/app_navigator_service.dart';
import 'package:globipay_admin_panel/core/services/storage/app_preferences_service.dart';
import 'package:globipay_admin_panel/core/widgets/app_print.dart';
import 'package:globipay_admin_panel/core/widgets/button/app_button.dart';
import 'package:globipay_admin_panel/core/widgets/button/app_outline_button.dart';
import 'package:globipay_admin_panel/data/repository/app_repository.dart';
import 'package:globipay_admin_panel/data/services/supabase_service.dart';
import 'package:globipay_admin_panel/entity/response/category/category_item_entity.dart';
import 'package:globipay_admin_panel/entity/response/category/category_response.dart';
import 'package:globipay_admin_panel/entity/response/chat_item/chat_item_response_entity.dart';
import 'package:globipay_admin_panel/entity/response/chat_session_response/chat_session_response.dart';
import 'package:globipay_admin_panel/modules/chat/controller/chat_shared_controller.dart';
import 'package:globipay_admin_panel/router/app_routes.dart';
import 'package:globipay_admin_panel/router/route_path.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/**
 * Created by Abdullah on 16/10/24 08:01 PM.
 */
class ChatMessageController extends BaseController {
  AppRepository _appRepository;

  TokenRepository tokenRepository;
  final ChatSharedController sharedController =
      Injector.resolve<ChatSharedController>();

  ChatMessageController(this._appRepository, this.tokenRepository);

  //Rx Variables
  RxList<ChatSessionResponse> chatList = RxList<ChatSessionResponse>([]);
  var userName = "".obs;
  final supabase = SupabaseService().client;

  List<CategoryItemEntity> categories = List<CategoryItemEntity>.empty(growable: true);

  @override
  onInit() async{
    super.onInit();
    fetchCategories();
    _listenForChatSessionChanges();
    _getUserInfo();
  }

  void _getUserInfo() async {
    final name =
        await PreferencesService.getString(PreferencesService.USER_NAME);
    userName.value = name ?? "";
  }

  PaginationRequest generatePaginationRequest() {
    return PaginationRequest(limit: 20, page: 1);
  }

  void goToChatScreen() async {
    final userID = await tokenRepository.getStuffId();
    sharedController.setCurrentUserId(userID);
    AppRoutes.pushNamed(RoutePath.chat)
        .then((value) => requestForMessageList());
  }

  void fetchAdminChatSessions() async {
    try {
      //final userID = await tokenRepository.getUserID();

      // Execute the remote procedure call
      final response = await supabase.rpc(
        'a_chat_session',
      );

      // Since the response is a list, check if it is empty
      if (response == null || (response as List).isEmpty) {
        chatList.value = [];
      }

      // Debugging log to see raw data
      appPrint('Response data: $response');

      // Map the result to your chat session entities
      final chatSessions = (response as List)
          .map((item) => getModifiedChatSessionResponse(item))
          .toList();

      // Update your chat list with the fetched chat sessions
      chatList.value = chatSessions;
      appPrint('Chat sessions: ${chatList.value.length}');
    } catch (e) {
      appPrint('Exception while loading chat sessions: $e');
    }
  }

  ChatSessionResponse getModifiedChatSessionResponse(session) {
    ChatSessionResponse chatSessionResponse =
        ChatSessionResponse.fromJson(session);
    CategoryItemEntity? category =
        getCategoryById(chatSessionResponse.category ?? "");
    chatSessionResponse.categoryName = category?.name ?? "";
    chatSessionResponse.categoryImage = category?.image ?? "";
    return chatSessionResponse;
  }

  void onMessageItemClicked(ChatSessionResponse message) async {
    appPrint("Session ID  : ${message.session_id}");

    if (message.status == "pending") {
      if(categories.isEmpty){
        await fetchCategories();
      }

      CategoryItemEntity? category = getCategoryById(message.category ?? "");

      if (category == null && message.category != "-1") {
        appPrint('Category not found for chat session: ${message.category}');
        showSnackBar(message: 'Category not found for chat session');
        return;
      }

      showPendingDialog(message: message, category: category ?? CategoryItemEntity());
      return;
    }

    sharedController.setChatSessionId(message.session_id);
    sharedController.setCustomerID(message.customer_id);
    sharedController.setChatSessionResponse(message);
    goToChatScreen();
  }

  CategoryItemEntity? getCategoryById(String id) {
    try {
      return categories.firstWhereOrNull((element) => element.id.toString() == id);
    } catch (e) {
      appPrint('Error getting category by id: $e');
      return null;
    }
  }

  void onAudioCall() {
    AppRoutes.pushNamed(RoutePath.audioCall);
  }

  void onVideoCall() {
    AppRoutes.pushNamed(RoutePath.videoCall);
  }

  // Network call


  void requestForMessageList() {
    fetchAdminChatSessions();
  }

  void _listenForChatSessionChanges() {
    appPrint('Setting up listener for chat session changes...');

    final channel = supabase.channel('public:chat_sessions')
      ..on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'INSERT',
          schema: 'public',
          table: 'chat_sessions',
        ),
        (payload, [ref]) async {
          if (payload['new'] != null) {
            final newSession = payload['new'];
            update();
            _updateUI(newSession);
            appPrint('New chat session INSERT: ${newSession}');
          }
        },
      )
      ..on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: 'UPDATE',
          schema: 'public',
          table: 'chat_sessions',
        ),
        (payload, [ref]) async {
          if (payload['new'] != null) {
            final newSession = payload['new'];
            update();
            _updateUI(newSession);

            appPrint('New UPDATED chat session UPDATE: ${newSession}');
          }
        },
      ).subscribe();
  }

  _updateUI(Map<String, dynamic> newSession) {
    final chatSession = ChatSessionResponse.fromJson(newSession);
    final index = chatList
        .indexWhere((element) => element.session_id == chatSession.session_id);
    if (index != -1) {
      if (chatSession.is_sender_typing ?? false == true) {
        chatList[index].last_message = "Typing...";
      } else if (chatSession.is_receiver_typing ?? false == true) {
        chatList[index].last_message = "Typing...";
      } else {
        chatList[index].last_message = chatSession.last_message;
        chatList[index].message_type = chatSession.message_type;
        chatList[index].last_message_timestamp =
            chatSession.last_message_timestamp;
      }
    }
    chatList.refresh();
  }

  void showPendingDialog({
    required ChatSessionResponse message,
    required CategoryItemEntity category,
  }) {
    showDialog(
      context: AppNavigatorService.navigatorKey.currentContext!,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return Dialog(
          backgroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20.0),
          ),
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                SizedBox(
                  height: 100,
                  width: 100,
                  child: Stack(
                    alignment: Alignment.center,
                    children: [
                      // Rotating outer circle
                      TweenAnimationBuilder(
                        tween: Tween(begin: 0.0, end: 1.0),
                        duration: const Duration(seconds: 2),
                        builder: (context, value, child) {
                          return Transform.rotate(
                            angle: value * 2 * pi,
                            child: Icon(
                              Icons.circle_outlined,
                              size: 80,
                              color: Colors.blue.shade400,
                            ),
                          );
                        },
                      ),
                      // Pulsing hourglass
                      TweenAnimationBuilder(
                        tween: Tween(begin: 0.8, end: 1.2),
                        duration: const Duration(milliseconds: 800),
                        curve: Curves.easeInOut,
                        builder: (context, value, child) {
                          return Transform.scale(
                            scale: value,
                            child: Icon(
                              Icons.hourglass_empty,
                              size: 40,
                              color: Colors.blue.shade700,
                            ),
                          );
                        },
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 20),
                FadeTransition(
                  opacity: CurvedAnimation(
                    parent: ModalRoute.of(context)!.animation!,
                    curve: Curves.easeIn,
                  ),
                  child: Text(
                    'Would you like to Accepts Chat Request',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      fontSize: 16,
                      color: Colors.grey[800],
                      height: 1.5,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
                const SizedBox(height: 20),
                SizedBox(
                  width: 400,
                  child: Row(
                    children: [
                      Expanded(
                        child: AppOutlineButton(
                          onPress: () {
                            AppRoutes.pop();
                          },
                          text: 'Cancel',
                        ),
                      ),
                      const SizedBox(width: 20),
                      Expanded(
                        child: AppButton(
                          onPress: () {
                            chatAccept(
                              message: message,
                              category: category,
                            );
                          },
                          text: 'Accept',
                        ),
                      ),
                      
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void chatAccept({
      required ChatSessionResponse message,
      required CategoryItemEntity category,}
      ) {
    updateSupabaseChatSession(
      message: message,
      category: category,
    );
    //goToChatScreen();
  }

  updateSupabaseChatSession({
    required ChatSessionResponse message,
    required CategoryItemEntity category,
  }) async {
    appPrint("Session ID ::::::::::::>>>> : ${sharedController.chatSessionId}");
    try {
      await supabase.from('chat_sessions').update({
        'status': 'open',
        'created_at': DateTime.now().toIso8601String(),
      }).eq('session_id', message.session_id).execute();

      if (message.category != "-1") {
        // Actual Implementation
        if (category.messageStatus ?? false) {
          sendOpeningTextMessage(category.message ?? "Hi, how can i help you ?",
              message.session_id ?? "");
        }
      }
    } catch (e) {
      appPrint('Error closing chat session: $e');
    }
    AppRoutes.pop();
    fetchAdminChatSessions();
  }

  Future<void> sendOpeningTextMessage(String text,String chatSessionId) async {
    final userID = await tokenRepository.getStuffId();

    final response = await supabase.from('messages').insert({
      'session_id': chatSessionId,
      'sender_id': userID,
      'message': text,
      'message_type':  'text', // Specify message type
      'status': 'sent', // Initial status
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
      'message_from': UserType.Admin.name,
      'delivery_status': {
        'sent': DateTime.now().toIso8601String(),
      } // Corrected structure
    }).select('id').execute(); // Add .select('id') to fetch the inserted id

  }

  PaginationRequest generatePaginationRequestForCategories() {
    return PaginationRequest(limit: 200, page: 1);
  }

  Future<void> fetchCategories() async {
    categories.clear();
    final repo = _appRepository.requestForCategories(generatePaginationRequestForCategories());
    callService(repo, onSuccess: (CategoryResponseEntity response) {
      parserCategories(response);
    });
  }

  void parserCategories(CategoryResponseEntity response) {
    categories = response.categories ?? [];
    requestForMessageList();

  }
}
